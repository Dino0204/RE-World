# 📊 State Management (상태 관리)

이 프로젝트는 데이터의 성격과 복잡도에 따라 두 가지 상태 관리 방식을 혼합하여 사용합니다.

## 1. Local State (`useReducer`)

플레이어의 움직임과 같이 한 컴포넌트 내에서만 긴밀하게 사용되는 상태는 `useReducer`를 사용합니다.

- **사용 위치**: `entities/player/ui/index.tsx`
- **장점**:
  - 관련 있는 여러 상태(이동 방향, 속도, 점프 여부 등)를 하나의 상태 객체로 관리할 수 있습니다.
  - 상태 변경 로직(`reducer`)이 컴포넌트 외부에 있어 테스트와 가독성이 좋습니다.

## 2. Global State (`Zustand`)

총알 시스템이나 사용자 프로필과 같이 여러 컴포넌트가 공유하거나, 빈번하게 추가/삭제되는 데이터는 `Zustand`를 사용합니다.

- **사용 위치**: `entities/bullet/model/store.ts`
- **장점**:
  - **Boilerplate 최소화**: Redux에 비해 설정이 매우 간단합니다.
  - **성능**: 필요한 상태 조각(Selector)만 구독하여 불필요한 리렌더링을 방지합니다.

## 언제 무엇을 사용하나?

| 기준            | useReducer (Local)        | Zustand (Global)             |
| :-------------- | :------------------------ | :--------------------------- |
| **데이터 범위** | 단일 엔티티 내부          | 여러 엔티티/컴포넌트 간 공유 |
| **데이터 수명** | 컴포넌트 언마운트 시 소멸 | 전역적으로 유지              |
| **복잡도**      | 중간                      | 낮음 ~ 높음 모두 가능        |

### Reactive Flow (반응형 흐름)

1. **이벤트**: 사용자가 키보드나 마우스를 조작합니다.
2. **상태 업데이트**: `dispatch`나 `store.set`을 통해 데이터가 바뀝니다.
3. **프레임 반영**: R3F의 `useFrame` 내부에서 최신 상태값을 읽어 물리 엔진이나 메쉬에 즉각 반영합니다.
